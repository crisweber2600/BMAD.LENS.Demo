const fs = require('node:fs/promises');
const path = require('node:path');

/**
 * Helper: Check if path exists
 */
async function pathExists(filePath) {
    try {
        await fs.access(filePath);
        return true;
    } catch {
        return false;
    }
}

/**
 * Helper: Ensure directory exists (recursive mkdir)
 */
async function ensureDir(dirPath) {
    await fs.mkdir(dirPath, { recursive: true });
}

/**
 * Helper: Copy file
 */
async function copyFile(src, dest) {
    await fs.copyFile(src, dest);
}

/**
 * Helper: Copy directory recursively
 */
async function copyDirRecursive(src, dest, { overwrite = false, logger, projectRoot, label }) {
    await ensureDir(dest);
    const entries = await fs.readdir(src, { withFileTypes: true });

    for (const entry of entries) {
        const sourcePath = path.join(src, entry.name);
        const destPath = path.join(dest, entry.name);

        if (entry.isDirectory()) {
            await copyDirRecursive(sourcePath, destPath, { overwrite, logger, projectRoot, label });
            continue;
        }

        const fileExists = await pathExists(destPath);

        if (fileExists && !overwrite) {
            logger.warn(`${label} already exists, skipping: ${path.relative(projectRoot, destPath)}`);
            continue;
        }

        await copyFile(sourcePath, destPath);

        if (fileExists) {
            logger.log(`✓ Updated ${label}: ${path.relative(projectRoot, destPath)}`);
        } else {
            logger.log(`✓ Installed ${label}: ${path.relative(projectRoot, destPath)}`);
        }
    }
}

/**
 * Helper: Create or update _bmad/_config/manifest.yaml
 */
async function updateManifest(bmadRoot, moduleName, moduleType, logger) {
    const configDir = path.join(bmadRoot, '_config');
    const manifestPath = path.join(configDir, 'manifest.yaml');

    try {
        await ensureDir(configDir);

        let manifestContent = '';
        let existingModules = [];

        // Read existing manifest if it exists
        if (await pathExists(manifestPath)) {
            manifestContent = await fs.readFile(manifestPath, 'utf-8');

            // Parse existing modules list (simple YAML parsing)
            const modulesMatch = manifestContent.match(/installed_modules:\s*\n((?:\s+-\s+.+\n)*)/);
            if (modulesMatch) {
                existingModules = modulesMatch[1]
                    .split('\n')
                    .filter(line => line.trim().startsWith('-'))
                    .map(line => line.trim().replace(/^-\s+/, ''));
            }
        }

        // Add new module if not already present
        if (!existingModules.includes(moduleName)) {
            existingModules.push(moduleName);

            // Build new manifest content
            const timestamp = new Date().toISOString();
            manifestContent = `# BMAD Module Manifest
# Auto-generated by LENS installer
# Last updated: ${timestamp}

installed_modules:
${existingModules.map(m => `  - ${m}`).join('\n')}

module_info:
  ${moduleName}:
    type: ${moduleType}
    installed_at: ${timestamp}
`;

            await fs.writeFile(manifestPath, manifestContent, 'utf-8');
            logger.log(`✓ Registered ${moduleName} in manifest`);
        }
    } catch (error) {
        logger.warn(`Warning: Could not update manifest.yaml: ${error.message}`);
    }
}

/**
 * Helper: Update .gitignore with LENS-specific entries
 */
async function updateGitignore(projectRoot, logger) {
    const gitignorePath = path.join(projectRoot, '.gitignore');
    const entriesToAdd = [
        '/TargetProjects',
        '/_bmad-output/personal'
    ];

    try {
        let gitignoreContent = '';
        let fileExists = await pathExists(gitignorePath);

        // Read existing .gitignore if it exists
        if (fileExists) {
            gitignoreContent = await fs.readFile(gitignorePath, 'utf-8');
        }

        // Check which entries are missing
        const missingEntries = entriesToAdd.filter(entry => {
            // Check if entry already exists (exact match or as part of a line)
            const lines = gitignoreContent.split('\n');
            return !lines.some(line => line.trim() === entry.trim());
        });

        if (missingEntries.length === 0) {
            logger.log('✓ .gitignore already contains LENS entries');
            return;
        }

        // Add missing entries
        let newContent = gitignoreContent;

        // Ensure file ends with newline before adding entries
        if (newContent.length > 0 && !newContent.endsWith('\n')) {
            newContent += '\n';
        }

        // Add LENS section header if adding entries
        if (fileExists && newContent.length > 0) {
            newContent += '\n# LENS - BMAD Method\n';
        } else {
            newContent = '# LENS - BMAD Method\n';
        }

        // Add each missing entry
        for (const entry of missingEntries) {
            newContent += entry + '\n';
        }

        // Write updated .gitignore
        await fs.writeFile(gitignorePath, newContent, 'utf-8');

        if (fileExists) {
            logger.log(`✓ Updated .gitignore with ${missingEntries.length} LENS entries`);
        } else {
            logger.log(`✓ Created .gitignore with ${missingEntries.length} LENS entries`);
        }
    } catch (error) {
        logger.warn(`Warning: Could not update .gitignore: ${error.message}`);
    }
}

/**
 * LENS Module Installer
 */
async function install(options) {
    const { projectRoot, installedIDEs, logger } = options;

    try {
        logger.log('Installing LENS module assets...');

        const bmadRoot = path.join(projectRoot, '_bmad');
        const lensRoot = path.join(bmadRoot, 'lens');
        const memoryRoot = path.join(bmadRoot, '_memory');

        // Ensure base directories exist
        await ensureDir(lensRoot);
        await ensureDir(memoryRoot);

        // Update .gitignore with LENS entries
        await updateGitignore(projectRoot, logger);

        // Install agents to _bmad/lens/agents
        const agentsSource = path.join(__dirname, '..', 'agents');
        const agentsDest = path.join(lensRoot, 'agents');

        if (await pathExists(agentsSource)) {
            await copyDirRecursive(agentsSource, agentsDest, {
                overwrite: false,
                logger,
                projectRoot,
                label: 'agent'
            });
        } else {
            logger.warn('No agents directory found in module. Skipping agent installation.');
        }

        // Install prompts to .github/prompts (for GitHub Copilot)
        const promptsSource = path.join(__dirname, '..', 'prompts');
        const promptsDest = path.join(projectRoot, '.github', 'prompts');

        if (await pathExists(promptsSource)) {
            await copyDirRecursive(promptsSource, promptsDest, {
                overwrite: false,
                logger,
                projectRoot,
                label: 'prompt'
            });
        } else {
            logger.warn('No prompts directory found in module. Skipping prompt installation.');
        }

        // Install module config files
        const configFiles = ['module-config.yaml', 'module.yaml', 'config.yaml'];
        for (const configFile of configFiles) {
            const configSource = path.join(__dirname, '..', configFile);
            if (await pathExists(configSource)) {
                const configDest = path.join(lensRoot, configFile);
                await copyFile(configSource, configDest);
                logger.log(`✓ Installed config: ${path.relative(projectRoot, configDest)}`);
            }
        }

        // Install extensions
        await installExtensions({
            projectRoot,
            logger,
            bmadRoot,
            lensRoot,
            memoryRoot,
            installedIDEs: installedIDEs || []
        });

        // Register lens core module in manifest
        await updateManifest(bmadRoot, 'lens', 'core', logger);

        if (installedIDEs && installedIDEs.length > 0) {
            for (const ide of installedIDEs) {
                await configureForIDE(ide, projectRoot, logger);
            }
        }

        logger.log('✓ LENS module installation complete');
        return true;
    } catch (error) {
        logger.error(`Error installing LENS module: ${error.message}`);
        return false;
    }
}

async function configureForIDE(ide, projectRoot, logger) {
    const platformSpecificPath = path.join(__dirname, 'platform-specifics', `${ide}.js`);

    try {
        if (await pathExists(platformSpecificPath)) {
            const platformHandler = require(platformSpecificPath);
            if (typeof platformHandler.install === 'function') {
                await platformHandler.install({ projectRoot, logger });
            }
        }
    } catch (error) {
        logger.warn(`Warning: Could not configure ${ide}: ${error.message}`);
    }
}

module.exports = { install };

async function installExtensions({ projectRoot, logger, bmadRoot, lensRoot, memoryRoot, installedIDEs }) {
    const extensionsDir = path.join(__dirname, '..', 'extensions');

    if (!(await pathExists(extensionsDir))) {
        logger.log('No extensions directory found. Skipping extension installation.');
        return;
    }

    // Discover all extensions
    const entries = await fs.readdir(extensionsDir, { withFileTypes: true });
    const extensions = entries.filter(e => e.isDirectory()).map(e => e.name);

    if (extensions.length === 0) {
        logger.log('No extensions found in extensions directory.');
        return;
    }

    for (const extensionName of extensions) {
        await installExtension({
            projectRoot,
            logger,
            bmadRoot,
            lensRoot,
            memoryRoot,
            extensionName,
            installedIDEs: installedIDEs || []
        });
    }
}

async function installExtension({ projectRoot, logger, bmadRoot, lensRoot, memoryRoot, extensionName, installedIDEs }) {
    const extensionRoot = path.join(__dirname, '..', 'extensions', extensionName);

    if (!(await pathExists(extensionRoot))) {
        logger.warn(`Extension not found, skipping: ${extensionName}`);
        return;
    }

    logger.log(`Installing ${extensionName} extension...`);

    // Create extension directory in _bmad/{extensionName}
    const extensionDest = path.join(bmadRoot, extensionName);
    await ensureDir(extensionDest);

    // Install extension agents to _bmad/lens/agents (merge with core)
    const agentsSource = path.join(extensionRoot, 'agents');
    const agentsDest = path.join(lensRoot, 'agents');
    if (await pathExists(agentsSource)) {
        const agentEntries = await fs.readdir(agentsSource, { withFileTypes: true });

        for (const entry of agentEntries) {
            const sourcePath = path.join(agentsSource, entry.name);
            const destPath = path.join(agentsDest, entry.name);

            if (entry.isDirectory()) {
                // Check if this is a _memory directory
                if (entry.name.endsWith('-sidecar') || entry.name === '_memory') {
                    // Install sidecar memory to _bmad/_memory
                    const sidecarName = entry.name.replace('_memory', '').replace(/\/$/, '');
                    const memoryDest = path.join(memoryRoot, sidecarName || entry.name);

                    await copyDirRecursive(sourcePath, memoryDest, {
                        overwrite: false,
                        logger,
                        projectRoot,
                        label: `extension sidecar (${extensionName})`
                    });
                } else {
                    // Regular agent directory
                    await copyDirRecursive(sourcePath, destPath, {
                        overwrite: false,
                        logger,
                        projectRoot,
                        label: `extension agent (${extensionName})`
                    });
                }
            } else {
                // Agent file (.yaml, .md, etc)
                await ensureDir(agentsDest);

                // Check if file exists before copying
                if (await pathExists(destPath)) {
                    logger.warn(`extension agent (${extensionName}) already exists, skipping: ${path.relative(projectRoot, destPath)}`);
                } else {
                    await copyFile(sourcePath, destPath);
                    logger.log(`✓ Installed extension agent (${extensionName}): ${path.relative(projectRoot, destPath)}`);
                }
            }
        }
    }

    // Install extension workflows to _bmad/lens/extensions/{name}/workflows
    const workflowsSource = path.join(extensionRoot, 'workflows');
    const workflowsDest = path.join(extensionDest, 'workflows');
    if (await pathExists(workflowsSource)) {
        await copyDirRecursive(workflowsSource, workflowsDest, {
            overwrite: false,
            logger,
            projectRoot,
            label: `extension workflow (${extensionName})`
        });
    }

    // Install extension prompts to .github/prompts (for GitHub Copilot)
    const promptsSource = path.join(extensionRoot, 'prompts');
    const promptsDest = path.join(projectRoot, '.github', 'prompts');
    if (await pathExists(promptsSource)) {
        await copyDirRecursive(promptsSource, promptsDest, {
            overwrite: false,
            logger,
            projectRoot,
            label: `extension prompt (${extensionName})`
        });
    }

    // Install extension hooks
    const hooksSource = path.join(extensionRoot, 'hooks');
    const hooksDest = path.join(extensionDest, 'hooks');
    if (await pathExists(hooksSource)) {
        await copyDirRecursive(hooksSource, hooksDest, {
            overwrite: false,
            logger,
            projectRoot,
            label: `extension hook (${extensionName})`
        });
    }

    // Install extension docs
    const docsSource = path.join(extensionRoot, 'docs');
    const docsDest = path.join(extensionDest, 'docs');
    if (await pathExists(docsSource)) {
        await copyDirRecursive(docsSource, docsDest, {
            overwrite: false,
            logger,
            projectRoot,
            label: `extension doc (${extensionName})`
        });
    }

    // Copy module config files
    const configFiles = ['module.yaml', 'README.md', 'TODO.md'];
    for (const configFile of configFiles) {
        const configSource = path.join(extensionRoot, configFile);
        if (await pathExists(configSource)) {
            const configDest = path.join(extensionDest, configFile);
            await copyFile(configSource, configDest);
        }
    }

    // Run extension-specific installer if it exists
    const extensionInstaller = path.join(extensionRoot, '_module-installer', 'installer.js');
    if (await pathExists(extensionInstaller)) {
        try {
            const extInstaller = require(extensionInstaller);
            if (typeof extInstaller.install === 'function') {
                // Pass minimal config - extension installers should be self-contained
                const config = {
                    output_folder: '_bmad-output',
                    state_folder: path.join('_bmad-output', extensionName),
                    project_root: projectRoot
                };

                await extInstaller.install({
                    projectRoot,
                    config,
                    installedIDEs: installedIDEs || [],
                    logger
                });
            }
        } catch (error) {
            logger.warn(`Warning: Extension installer failed for ${extensionName}: ${error.message}`);
        }
    }

    // Register extension in manifest
    await updateManifest(bmadRoot, extensionName, 'extension', logger);

    logger.log(`✓ ${extensionName} extension installed`);
}

async function installExtensionAssets({ projectRoot, logger, extensionName }) {
    // Deprecated: kept for backward compatibility
    // Extensions are now installed via installExtension()
    logger.warn(`installExtensionAssets is deprecated, use installExtension instead`);
}
